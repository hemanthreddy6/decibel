# Semantic checks that we have done:

1) Type checking: All the types of variables are checked when operators are performed on them or they are assigned to another variable.
    - When the basic data types (bool, int, long, float) are assigned to each other/operators are done between them, decibel implicitly typecasts between these data types.
    - These 4 basic data types can also be implicitly typecast to strings
    - when a function variable is assigned a function expression, the function type of both have to be exactly equal
    - For the (+, -, *, /, %) operators, if the operators are done between two functions, it will return a function of the same type as long as the return type of the function
        allows that operator.
    - All the type checks have also been done for audio operations to ensure the operators are being used correctly, according to how we defined them in the whitepaper.

2) Symbol table:
    - Our functions do not share scope with the scope they are defined in, and can only access globally defined variables.
    - To implement this, we actually have a list of symbol tables instead of a single symbol table.
    - The first symbol table is the global one, which contains all the code that's not inside a function expression
    - The first scope level in the first symbol table is the global scope
    - For every function definition, we create a new symbol table, and implement checks to ensure that all the variables that are being accessed are either within this scope or
        the global scope.

3) Error handling:
    - We have done extensive error handling, with every error giving a meaningful error message, as well as visually showing where this error occured by printing the line and pointing
        to the place where the error occured.
    - Errors are generated by first setting the yylval to the node where the error occured and then calling the yyerror() function. This allows yyerror to know the line number
        and column number of the error, which allows for useful error messages.

4) Abstract Syntax Tree:
    - The parser will incrementally build an AST, which consists of nodes.
    - Each node has an enum value called node_type, which is used to know what type of node it is.
    - It also has a vector of children nodes, as well as a data_type.
    - Using this information, as well as some other fields like node.text, we can know how to parse and do type check for each node, as well as which of it's children 
        to traverse at what time.

